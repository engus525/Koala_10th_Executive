## 3주차 모의테스트 해설
<br>

### A. [개미](https://www.acmicpc.net/problem/10158)
- 풀이
>가로와 세로를 따로 생각합니다. 주기는 각각 2w, 2h이므로, p + t를 주기로 나눠준 후 처리합니다.<br>
가로 세로 길이를 넘는 값을 가질 경우, 반대 방향으로 이동한다는 의미이므로 주기에서 p + t값을 빼줍니다.
- 예시 코드
>http://boj.kr/f05ceb8af6c544c7bb23ff7582d3f8fe

****************************

### B. [통나무 건너뛰기](https://www.acmicpc.net/problem/11497)
- 풀이
>각각의 통나무 높이를 우선순위 큐에 넣어 내림차순으로 정렬합니다. 통나무들을 배치할 deque도 만들어줍니다.<br>
그 다음, for문을 이용해 우선순위 큐에서 하나씩 통나무를 뽑아내어 deque에 넣어줍니다.<br>
이때, 우선순위 큐의 통나무를 앞뒤로 삽입한 것이 최소 난이도를 가지게 됩니다. 따라서 deque의 앞뒤에 번갈아가며 삽입을 진행합니다.<br>
이후 deque에서 인접한 두 통나무 간의 높이 차이의 최댓값을 구합니다.
- 예시 코드
>http://boj.kr/8526b0ce6ffc4cbb9784620468df6a6f


****************************

### C. [발전소 설치](https://www.acmicpc.net/problem/1277)
- 풀이
>다음 네 가지 조건에 유의하여 dijkstra 알고리즘으로 문제를 해결합니다.<br>
>1. 현재 노드와 다음 노드 간의 전선이 남아있는 경우, 전선 길이가 추가되지 않는다.<br>
>2. 현재 노드와 다음 노드가 같은 경우, 방문하지 않는다.<br>
>3. 현재 노드와 다음 노드 간의 전선이 남아있지 않고, 거리가 m보다 큰 경우 방문하지 않는다.<br>
>4. 다음 노드로의 더 짧은 경로가 존재한다면, 방문하지 않는다.<br>
- 예시 코드
>http://boj.kr/b28a0e3c02af4d72b4a3ef06bd588377


****************************

### D. [원판 돌리기](https://www.acmicpc.net/problem/17822)
- 풀이
>인접하는 수 판별은 DFS/BFS를 사용할 수 있습니다. 이때 원형 배열로 구현해야하므로, 인덱스 조정을 통해 인접 수를 판별합니다.<br>
회전 알고리즘은 다양하지만, 아래 방법이 깔끔하여 사용하기 좋습니다.<br>
>1. 앞에서부터 k개의 원소를 temp 배열에 저장해둡니다.<br>
>2. 뒤에서부터 k칸 앞의 원소를 덮어씁니다.<br>
>3. temp에 저장해둔 원소를 앞에서부터 채웁니다.<br><br>
>회전과 인접 수 삭제를 반복하다가 인접 수가 없다면, 배열 내 각 원소의 수를 조정하게되는데 이때 총합과 평균을 구할 때 나누는 수 또한 변할 수 있음에 유의합니다.<br>
- 예시 코드
>http://boj.kr/52279bb4a2d44b7f8ed49326e335e2d1

