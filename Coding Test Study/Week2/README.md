## 2주차 모의테스트 해설
<br>

### A. [핸드폰 번호 궁합](https://www.acmicpc.net/problem/17202)
- 풀이
>010을 제외한 A와 B의 번호를 한 자리씩 번갈아가며 이어붙인 자료구조를 생성합니다.<br>
가장 앞에서부터 두 숫자씩 더한 값을 10으로 나눴을 때의 나머지를 자료구조의 맨 앞부터 변경해나갑니다.<br>
모든 쌍에 대해 변경했다면, 맨 뒤 숫자를 제거해줍니다. 이를 자료구조의 크기가 2가 될 때까지 반복합니다.<br>
- 예시 코드
>http://boj.kr/effea00bfab44c33b1df42b4c810e572

****************************

### B. [점화식](https://www.acmicpc.net/problem/13699)
- 풀이
>dp 배열을 생성하여 dp[0] = 1로 초기화한 뒤, 반복문 혹은 재귀를 통하여 dp 배열을 앞에서부터 채워갑니다.<br>
n이 35이하이므로, 출력값이 int 범위를 벗어남에 유의합니다.<br>
- 예시 코드(Top-Down 사용)
>http://boj.kr/e990f50a187c49e4a362e48ea856d9f3


****************************

### C. [이동하기](https://www.acmicpc.net/problem/11048)
- 풀이
>이차원 dp배열을 생성합니다. dp[x][y]는 (x,y)지점까지 가져올 수 있는 사탕의 최댓값을 의미합니다.<br>
사탕의 갯수는 0이상입니다. 따라서 오른쪽 아래 대각선 방향으로 바로 이동하는 것보다, 오른쪽이나 아래를 방문한 후 이동하는 것이 반드시 이득입니다.<br>
즉, (현재 지점의 왼쪽과 위쪽 지점 중 더 큰 값)에 (현재 지점의 사탕)을 더해준 값이 dp[x][y]이 됩니다.<br>
결론적으로, 점화식은 dp[x][y] = max(dp[x][y - 1], dp[x - 1][y]) + map[x][y]이 됩니다.<br>
- 예시 코드
>http://boj.kr/170088c9650f4b0f8765771f5efa5bd6


****************************

### D. [팰린드롬?](https://www.acmicpc.net/problem/10942)
- 풀이
>S와 E가 같으면 반드시 팰린드롬이라는 것과, S번째의 수와 E번째의 수가 같으면서 S+1에서 E-1 구간이 팰린드롬이라면 S에서 E또한 팰린드롬이라는 것을 이용하여 해결합니다.<br>
이차원 배열을 생성하여, 각 (S,E)에 대해 팰린드롬 여부를 기록합니다.<br>
예전에 포스팅했던 [블로그](https://velog.io/@engus525/백준-10942번-팰린드롬)도 함께 첨부합니다.
- 예시 코드
>http://boj.kr/588718dc651d41fa933e700b18bc45d8

